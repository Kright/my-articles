Текст буду дописывать, сейчас он ближе к перечислению интересных идей и концепций из разных языков.

### Гомоиконность

[wikipedia](https://en.wikipedia.org/wiki/Homoiconicity)

Идея в том, что код на языке программирования может быть представлен в виде данных и как-то преобразован. Пример - Lisp-подобные языки.

```Lisp
(* (+ 2 2) 2)
```

Можно смотреть на это как на код, а можно как на список. Структура списка совпадает с синтаксическим деревом.
Такой подход даёт шикарную поддержку метапрограммирования, макросы манипулируют с кодом как с обычными списками, а потом код можно запустить.

Для манипулирования с кодом в языке нужен механизм quoting (получить данные, описывающие код) и splicing (преобразовать эти данные обратно в код)

### Evaluation strategy

[wikipedia](https://en.wikipedia.org/wiki/Evaluation_strategy)

Внезапно в википедии оказалась целая табличка с кучей разных способов, но глобально я бы их разделил на три:

1. **Call by value** - то что есть в большинстве языков программирования, когда все аргументы функции вычисляются перед её вызовом.
2. **Сall by name** - аргумент "лениво" передаётся в функцию и вычисляется только если понадобится, но может вычисляться несколько раз. Используется в обычных языках для boolean в выражениях типа `bool1 && bool2`.
3. **Call by need** - как call by name, но результат первого вычисления запоминается. Используется в Haskell.

Всякие варианты типа передачи указателей или константных ссылок не вижу смысла рассматривать, можно считать что это call by value c передачей указателя на что-то.

В Scala есть поддержка варианта вызова по имени, и эта возможность крутая. Пример:

```Scala
sealed trait MyBool
case object MyFalse extends MyBool
case object MyTrue extends MyBool

def f1(): MyBool =
    println("f1")
    MyFalse

def f2(): MyBool =
    println("f2")
    MyTrue

def myAnd(left: MyBool, right: => MyBool): MyBool =
    if (left == MyFalse)
        MyFalse
    else
        right

myAnd(f1(), f2())
```

В принципе, всё то же самое сделано с bool значениями в большинстве языков, но обычно средствами языка сделать похожий тип невозможно.

кроме того, всякие конструкции типа
```
map.getOrElse(key, new Value())
```
не будут создавать new Value, если в map что-то есть. Очень удобно и красиво.

### Синтаксис вызова функций

Самый известный как в Си:
```C
f(1, 2, g())
```

В LISP открывающая скобка стоит до имени функции.
```Lisp
(f 1 2 (g ()))
```
Почему-то в лиспе мне периодически кажется, что в итоге скобочек слишком много.

Кроме того, в Haskell это могло бы выглядеть так:

```Haskell
f 1 2 (g ())
```

В принципе как в Lisp, но с меньшим количеством скобок.
Причём с трочки зрения Haskell аргументы передаются по одному. Типа f принимает 1, возвращает функцию, в которую передают 2, та возвращает функцию, в которую передают (g ()).
И можно передать пару аргументов, поделать какую-то логику, а потом передать ещё один аргумент.

В Scala такое тоже возможно, но синтаксис другой:
```
val func = f(1, 2, _)
func(g1 ())
```
При таком подходе язык не запрещает использовать каррирование, но оно используется осмысленно и только там где нужно, все остальные вызовы работают эффективно и не создают лямбд.

Ещё есть забавный (и близкий к ассемблеру) вариант в языке Forth - там все аргументы просто кидаются на стек, а потом вызывается функция.

В некоторых языках (Groovy, Kotlin, Scala, C#) можно делать extensions methods

```Scala
extension (a: Int) def myAdd (b: Int): Int = a + b

1.myAdd(2)
```

По-факту это те же самые функции от двух аргументов, но с другим синтаксисом для вызова.

Иногда языки разрешают опускать скобочки

```Scala
1 myAdd 2
```

Я не встречал попыток обобщить этот подход на более общий случай, теоретически могло бы быть так:
```Scala
def[T] if(cond: Boolean) then (body: => T) else (otherBody: => T): T = ...
```
тогда можно было бы вводить "новые" базовые конструкции языка.

Но остаётся открытым вопрос с разрешением неоднозначности таких конструкций. Например, если рядом будет второе определение, но без else:

```Scala
def if(cond: Boolean) then (body: => Unit)
```
Парсер будет должен догадаться использовать более длинное определение.


