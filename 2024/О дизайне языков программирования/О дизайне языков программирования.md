Текст буду дописывать, сейчас он ближе к перечислению интересных идей и концепций из разных языков.

### Гомоиконность

[wikipedia](https://en.wikipedia.org/wiki/Homoiconicity)

Идея в том, что код на языке программирования может быть представлен в виде данных и как-то преобразован. Пример - Lisp-подобные языки.

```Lisp
(* (+ 2 2) 2)
```

Можно смотреть на это как на код, а можно как на список. Структура списка совпадает с синтаксическим деревом.
Такой подход даёт шикарную поддержку метапрограммирования, макросы манипулируют с кодом как с обычными списками, а потом код можно запустить.

Для манипулирования с кодом в языке нужен механизм quoting (получить данные, описывающие код) и splicing (преобразовать эти данные обратно в код)

### Evaluation strategy

[wikipedia](https://en.wikipedia.org/wiki/Evaluation_strategy)

Внезапно в википедии оказалась целая табличка с кучей разных способов, но глобально я бы их разделил на три:

1. **Call by value** - то что есть в большинстве языков программирования, когда все аргументы функции вычисляются перед её вызовом.
2. **Сall by name** - аргумент "лениво" передаётся в функцию и вычисляется только если понадобится, но может вычисляться несколько раз. Используется в обычных языках для boolean в выражениях типа `bool1 && bool2`.
3. **Call by need** - как call by name, но результат первого вычисления запоминается. Используется в Haskell.

Всякие варианты типа передачи указателей или константных ссылок не вижу смысла рассматривать, можно считать что это call by value c передачей указателя на что-то.

В Scala есть поддержка варианта вызова по имени, и эта возможность крутая. Пример:

```Scala
sealed trait MyBool
case object MyFalse extends MyBool
case object MyTrue extends MyBool

def f1(): MyBool =
    println("f1")
    MyFalse

def f2(): MyBool =
    println("f2")
    MyTrue

def myAnd(left: MyBool, right: => MyBool): MyBool =
    if (left == MyFalse)
        MyFalse
    else
        right

myAnd(f1(), f2())
```

В принципе, всё то же самое сделано с bool значениями в большинстве языков, но обычно средствами языка сделать похожий тип невозможно.

кроме того, всякие конструкции типа
```
map.getOrElse(key, new Value())
```
не будут создавать new Value, если в map что-то есть. Очень удобно и красиво.

### Синтаксис вызова функций

Самый известный как в Си:
```C
f(1, 2, g())
```

В LISP открывающая скобка стоит до имени функции.
```Lisp
(f 1 2 (g ()))
```
Почему-то в лиспе мне периодически кажется, что в итоге скобочек слишком много.

Кроме того, в Haskell это могло бы выглядеть так:

```Haskell
f 1 2 (g ())
```

В принципе как в Lisp, но с меньшим количеством скобок.
Причём с трочки зрения Haskell аргументы передаются по одному. Типа f принимает 1, возвращает функцию, в которую передают 2, та возвращает функцию, в которую передают (g ()).
И можно передать пару аргументов, поделать какую-то логику, а потом передать ещё один аргумент.

В Scala такое тоже возможно, но синтаксис другой:
```
val func = f(1, 2, _)
func(g1 ())
```
При таком подходе язык не запрещает использовать каррирование, но оно используется осмысленно и только там где нужно, все остальные вызовы работают эффективно и не создают лямбд.

Ещё есть забавный (и близкий к ассемблеру) вариант в языке Forth - там все аргументы просто кидаются на стек, а потом вызывается функция.

В некоторых языках (Groovy, Kotlin, Scala, C#) можно делать extensions methods

```Scala
extension (a: Int) def myAdd (b: Int): Int = a + b

1.myAdd(2)
```

По-факту это те же самые функции от двух аргументов, но с другим синтаксисом для вызова.

Иногда языки разрешают опускать скобочки

```Scala
1 myAdd 2
```

Я не встречал попыток обобщить этот подход на более общий случай, теоретически могло бы быть так:
```Scala
def[T] if(cond: Boolean) then (body: => T) else (otherBody: => T): T = ...
```
тогда можно было бы вводить "новые" базовые конструкции языка.

Но остаётся открытым вопрос с разрешением неоднозначности таких конструкций. Например, если рядом будет второе определение, но без else:

```Scala
def if(cond: Boolean) then (body: => Unit)
```

Парсер будет должен догадаться использовать более длинное определение.

### Кортежи и Unit

В паскале и делфи были две отдельные сущности - процедуры и функции. Первые не возвращали ничего, вторые возвращали.

Во многих ЯП в функцию можно передавать N параметров, но возвращать можно только один. И например в jvm это прибито гвоздями на уровне байткода. Можно сделать объект для пары чисел, но jvm будет создавать его как объект и производительность будет ниже.

В некоторых языках (Python, Go) всё симметрично и можно возвращать несколько значений. В некоторых других языках (С++, Scala) в стандартной библиотеке есть кортежи и функция может их возвращать. Бонусом вместе с кортежами обычно идёт синтаксис для их распаковки.

```Scala
val (x, y) = getPair()
```

На тип Unit можно смотреть как на кортеж из нуля элементов. А на процедуру - как на функцию с возвращаемым типом Unit.

И если сделать в языке встроенную поддержку кортежей, то получается красивый универсальный вид:

1. Процедуры это функции, которые возвращают Unit
2. Функция может возвращать любое количество аргументов
3. Функция принимает любое количество аргументов (и они по-сути тоже кортеж)

Ещё кортежи можно назвать типами-произведениями.

### Структуры и именованные кортежи

Если не обращать внимание на изменяемость, можно заметить что структуры в Си это по-сути кортежи, но у каждого поля есть удобное уникальное имя.
Но, к сожалению, есть нюансы с работой `sizeof()` и структура без элементов может оказатья размером в один байт (а в идеале там должен быть нулевой размер)

Причём на аргументы функции тоже можно смотреть как на именованный кортеж, в некоторых языках возможна запись вида `f(x=1, y=1)`.

Причём если смотреть на функцию, как на штуку, которая на вход принимает кортеж, то задачи типа "сделать обёртку функции" оказываются вполне простыми и не зависящими от того "сколько аргументов передано", потому что аргумент только один в виде кортежа.

Или, например, можно будет определить `Set<T> = Map<T, Unit>` и в идеале не занимать место под хранение значений.

### Виды неизменяемости

Их несколько, и неплохо бы их различать:

1. изменяемая переменная
2. переменная, которую в текущем контексте изменить нельзя, но вообще говоря она может поменяться
3. переменная, которая не будет изменена, пока на неё есть неизменяемая ссылка (как в Rust)
4. неизменяемая переменная, которая когда-то инициализирована и больше никогда не поменяется
5. константа времени компиляции

Какие есть нюансы:
В динамических языках понятия компиляции и выполнения смешаны и особых проблем нет. В статическом языке, если хочется иметь какие-то вычисления времени компиляции (привет constexpr в C++), по-факту придётся придумывать какое-то подмножество языка (или даже получать другой язык). Появятся всякие `contexpr if, contexpr int f()` и т.п.

Неизменяемые переменные, которые в будущем не поменяются, очень удобны для многопоточного программирования.

Для пунта 3: у ссылки есть lifetime, и пока ссылка актуальная, доступное по ней значение не изменится. Язык разрешает иметь либо одну изменяемую, либо много неизменяемых ссылок.

Для пункта 2 в С++ есть всякие константные ссылки и констанстные методы, но они действуют "целиком" на весь объект.

Теоретически можно изменяемость из пункта 2 сделать с помощью интерфейсов. Собственно, в JVM языках так обычно и делают.

В языках типа C++ и Rust сложно делать константные объекты, для них пропадает возможность перемещения. Для языков с GC такой проблемы нет.

### Nullability

Ошибки с null легко допустить и их хочется избегать.
Можно в системе типов разделить типы на те, что допускают null, и те где нельзя.

В Kotlin это сделано типом c ? в конце. Например
```
String // non nullable
String? // nullable
(String?)? // same as String?
```

Запись очень компактная, но мне такое не нравится. При обобщённом программировании это может доставить боль, потому что абстрактный тип T может быть любым. И что хуже, для `T = String?` получится что `T? == T`, но для `T=String` будет `T != T?`

На мой взгляд, это усложняет язык, и было бы удобнее иметь (с точки зрения системы типов) отдельные типы Option[String], Option[Option[String]] и т.п.

Вопросы со звёздочкой:
1. как сделать, чтобы тип Option[Pointer] занимал места в памяти как обычный нулевой указатель?
2. Что делать с Optional[int]?

### Модели дженериков

Вдохновлено следующей статьей: [https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/](https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/)

глобально есть два подхода:
1. мономорфизация: сгенерировать новую версию кода для каждого типа. Сюда можно отнести дженерики, макросы, кодогенерацию. Языки - C, C++, Rust, Haskell, Go, Zig.
2. boxing: смотреть на разные объекты каким-то общим спобосом.
    1. type erased generics - как коллекции в java, во время исполнения их тип не известен
    2. vtables - в объекте хранится таблица с методами (С++, Java, Go, Rust, Python)
    3. dictionary passing - передавать табличку с функциями. (тайпклассы в Haskell, witness table в Swift)

Минус мономорфизации - раздувание исходного кода и замедление компиляции.
Минус боксинга - потенциально более низкая производительность.

В Ocaml забавный boxing - все объекты одинакового размера, но по самым первым битам можно узнать, что в объекте - реальное значение (int) или ссылка на что-то в куче.
В Swift witness table содержат информацию о том, как объект двигать или копировать. И вдобавок в Swift есть аннотация `@inlineable`, чтобы сгенерировать быстрый код как в С++.

Ещё интересный момент - язык с JIT может сделать шаг от "универсальой" функции к мономорфизации и в горячих местах получить более производительный код.

### Как можно создавать объекты

Подходов несколько:

1. Статические константы и переменные (синглтоны), доступные всё время жизни программы. Из плюсов - простой подход, не надо думать про время жизни. Можно положить данные в область памяти, защищённую от записи. Такой подход часто используется в микроконтроллерах. Из минусов - подход применим только к штукам, которые точно будут нужны.
2. Можно выделять объекты на стеке, бонусом идёт автоматическое освобождение памяти, минусом - от освобождения отказаться нельзя, это же место на стеке в будущем будет переиспользовано и объект "протухнет". Размер стека ограничен (порядка 1-10Мб, при желании можно сделать больше).
3. Можно создавать объекты в куче и управлять указателями на них вручную либо через подсчёт ссылок. Плюсы - объект лежит в куче, размер объекта не важен, можно передавать указатель на него. Минусы - выделение памяти в куче может быть чуть медленнее, чем на стеке. Возможны ошибки типа утечек памяти или попыток удалить объект несколько раз. Возможна фрагментация памяти, когда по ней раскиданы мелкие объекты и между ними не влазит что-то более большое.
4. [Region-based](https://en.wikipedia.org/wiki/Region-based_memory_management): под какую-то задачу создаётся регион памяти, в нём создаются временные объекты, потом при завершении задачи весь регион освобождается. Плюсы - простое и быстрое освобождение памяти. Частичная устойчивость к утечкам: они будут внутри региона. Регионы можно использовать по-разному: например, можно вообще не освобождать объекты, создавать каждый новый в новом месте, не использовать дестркуторы и потом освобождать всё целиком. Будет просто, быстро, но возможно не эффективно по потреблению памяти. Либо можно разрешить "освобождать" объекты в регионе, но появятся проблемы с фрагментацией памяти. Подход используется в геймдеве - например, можно сделать регион для объектов игрового уровня и при переходе игрока на другой уровень его освободить. Ещё вариация: кастомный аллокатор для какого-то конкретного типа. Например, можно сделать массив на тысячу игровых объектов, при "создании" аллокатор будет возвращать ссылку на какой-нибудь объект в массиве, при освобождении отмечать его как "неиспользуемый". Плюсы: компактное расположение объектов, удобное итерирование по всем объектам этого типа. Минусы - вряд ли есть смысл делать отдельные аллокаторы для каждого типа. Если использовать заранее созданный массив какого-то размера, то будет ограничение сверху на количество объектов, причём память будет занята независимо от того, сколько реально объектов было создано.
5. Использовать GC. На мой взгляд, между GC и подсчётом ссылок есть принципиальная разница: обычно GC может двигать объекты в куче, обновляя ссылки между объектами. Это позволяет избегать фрагментации, но лишает контроля над расположением объектов в памяти. Технически в языке с GC могут быть деструкторы (finalize в Java), но их использоване не рекомендуется. Из плюсов - утечку памяти сделать сложно. Код проще, особенно многопоточный. Вся сложность многопточного освобождения объектов и их обхода ложится на виртуальную машину, но она одна, а программ - много. Минусы - меньше контроля, потенциально более низкая производительность. Теоретически, виртуальная машина внутри может использовать регионы, как-то перекидывать объекты между ними и потом освобождать регион с неиспользуемыми объектами одним махом. Опять же, в качестве оптимизации виртуальная машина может располагать временные объекты на стеке, но это не гарантируется. Ещё важный момент - трудно "поженить" два языка, если в каждом из них свой GC, не знающий про другой. Кроме того, обычно в языке либо вообще нет GC, либо он есть для всего что есть в языке, "промежуточных" вариантов толком нет. Возможно, для "промежуточных" вариантов нужны какие-то доработки системы типов, чтобы различать контексты "внутри GC" и "без GC" и не давать ссылкам на GC-объекты уходить наружу. Так как GC должен знать про все ссылки на GC-объект, чтобы его перемещать или освобождать. Но при этом из мира "без GC" должна быть какая-то возможность манипулировать объектами, например в имплементации GC.

### Исключения.

1. Можно их не использовать (C, Go, Rust). Язык становится проще. Из минусов - приходится явно передавать коды ошибок или ещё что-то по цепочке и иметь накладные расходы на их передачу/проверку. Обычно для непредвиденных случаев всё ещё остаётся exit(0) или её аналог для фатальной ошибки.
2. Checked exceptions. Исключения, которые надо явно указывать в сигнатуре функции. И язык и код на нём становятся сложнее, причём бывают случаи, когда в сигнатуре интерфейса исключение есть, а на практике его никто не кинет, но обрабатывать всё равно надо. По-факту идея не очень удобная, в языках Scala/Kotlin от неё отказались.
3. Unchecked exceptions. Плюсы - обычно нет больших накладных расходов, если код не кидает исключений. Если код их кидает, производительность может сильно просаживаться. Fun fact - В Python код, бросающий исключения, работает так же медленно, как и нормально исполняющийся, просто питон сам по себе очень медленный. усложняется язык программирования, для RAII нужна специальная поддержка. Минусы - язык становится сложнее, исключение может прилететь из какого-нибудь неожиданного места.














