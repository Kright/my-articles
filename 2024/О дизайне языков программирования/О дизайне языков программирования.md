Текст буду дописывать, сейчас он ближе к перечислению интересных идей и концепций из разных языков.

### Гомоиконность

[wikipedia](https://en.wikipedia.org/wiki/Homoiconicity)

Идея в том, что код на языке может быть представленна в виде данных и как-то преобразован. Пример - Lisp-подобные языки.

```Lisp
(* (+ 2 2) 2)
```

Можно смотреть на это как на код, а можно как на список. Структура списка совпадает с синтаксическим деревом.
Такой подход даёт шикарную поддержку метапрограммирования, макросы манипулируют с кодом как с обычными списками, а потом код можно запустить.

Для манипулирования с кодом в языке нужен механизм quoting (получить данные, описывающие код) и splicing (преобразовать эти данные обратно в код)

### Evaluation strategy

[wikipedia](https://en.wikipedia.org/wiki/Evaluation_strategy)

Внезапно в википедии оказалась целая табличка с кучей разных способов, но глобально я бы их разделил на три:

1. **Call by value** - то что есть в большинстве языков программирования, когда все аргументы функции вычисляются перед её вызовом.
2. **Сall by name** - аргумент "лениво" передаётся в функцию и вычисляется только если понадобится, но может вычисляться несколько раз. Используется в обычных языках для boolean в выражениях типа `bool1 && bool2`.
3. **Call by need** - как call by name, но результат первого вычисления запоминается. Используется в Haskell.

Всякие варианты типа передачи указателей или константных ссылок не вижу смысла рассматривать, можно считать что это call by value c передачей указателя на что-то.

В Scala есть поддержка варианта вызова по имени, и эта возможность крутая. Пример:

```Scala
sealed trait MyBool
case object MyFalse extends MyBool
case object MyTrue extends MyBool

def f1(): MyBool =
    println("f1")
    MyFalse

def f2(): MyBool =
    println("f2")
    MyTrue

def and(left: MyBool, right: => MyBool): MyBool =
    if (left == MyFalse)
        MyFalse
    else
        right

and(f1(), f2())
```

В принципе, всё то же самое сделано с bool значениями в большинстве языков, но обычно средствами языка сделать похожий тип невозможно.

кроме того, всякие конструкции типа
```
map.getOrElse(key, new Value())
```
не будут создавать new Value, если в map что-то есть. Очень удобно и красиво.



